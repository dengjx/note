> HotSpot 虚拟机是Java常用的虚拟机。

# 对象的创建

&emsp;&emsp;Java在创建对象（如克隆、反序列化）的时候通常仅仅使用 `new` 关键字而已，但是在虚拟机（这里指常见的HotSpot虚拟机）中，对象（限指普通对象，不含数组和Class对象等）的创建过程是如何的呢？

```java
A a = new A(); // 一般Java开发创建对象用new关键字即可
```

&emsp;&emsp;但是在虚拟机中创建对象的过程却是相对复杂得多了。其创建过程大概如下图：

![img-23](https://note.youdao.com/yws/api/personal/file/0506A5D79C67469BB2606B953AD353D8?method=download&shareKey=d79d4da046bf23ed7a3de6ddf113ec45)

## 步骤一：类加载检查

&emsp;&emsp;虚拟机遇到一条 `new` 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有就进行类加载过程（具体参考类加载过程）。

## 步骤二：为对象分配内存

&emsp;&emsp;类加载检查通过之后，为新对象分配内存（内存大小在类加载完成后便可确认）。内存分配的分配方式有两种：**指针碰撞**和**空闲列表**。

> Java堆内存规整：已使用的内存在一边，未使用内存在另一边
>
> Java堆内存不规整：已使用的内存和未使用内存相互交错
>
> ![img-24](https://note.youdao.com/yws/api/personal/file/E99BB58511CE4B63BD8DBACEE4C1621C?method=download&shareKey=e0ee6d4e826f9815dc8c6f7a7373db4c)
>
> **方式一：指针碰撞**
>
> 假设Java堆内存绝对规整，内存分配将采用指针碰撞。
>
> 分配形式：已使用内存在一边，未使用内存在另一边，中间放一个指针作为分界点的指示器，那所分配内存就是把那个指针向空闲空间那边挪动一段与对象想等大小的空间。
>
> **方式二：空闲列表**
>
> 假设Java堆内存不规整，内存分配将采用空闲列表。
>
> 分配形式：虚拟机维护着一个记录可用内存块的列表，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
>
> &emsp;&emsp;选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
>
> &emsp;&emsp;因此，使用Serial、ParNew等带Compact过程的垃圾收集器时，采用指针碰撞。而使用CMS这种基于Mark_sweep算法的垃圾收集器时，采用空闲列表。

**特别注意：**

对象创建在虚拟机中是非常频繁的操作，即使仅仅修改一个指针所指向的位置，在并发情况下也会引起线程不安全，如虚拟机可能正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存。所以在**给对象分配内存会存在线程不安全的问题。**为了解决这个问题有两种解决方案：

+ 对分配内存空间的动作进行同步处理。

&emsp;&emsp;虚拟机采用CAS + 失败重试的方式保证更新操作的原子性。

+ 把内存分配行为按照线程划分在不同的内存空间进行

&emsp;&emsp;即每个线程在 Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer ，TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时才需要同步锁。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。

## 步骤三：将内存空间初始化为零值

&emsp;&emsp;内存分配完成后，虚拟机需要将分配到的内存空间初始化为零（不包括对象头），如果使用本地线程分配缓冲（TLAB），这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中使用时可不赋初始值就直接使用（即对应值 = 0）。

## 步骤四：对对象进行必要的设置

&emsp;&emsp;完成前面三步后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。根据虚拟机当前的运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。

---

&emsp;&emsp;到此，前面几个步骤完成后，**从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始**，因为所有字段都还为零，因此还需要进行一些初始化操作，执行<init>方法进行初始化操作。一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

# 对象的内存布局

&emsp;&emsp;在HotSpot虚拟机中，对象在内存中存储的布局分为3个区域：**对象头（Header）**、**实例数据（Instance Data）**和**对齐填充（Padding）**。

## 对象头

&emsp;&emsp;对象头包括两部分信息：

- 用于存储对象自身的运行时数据（Mark Word）

1. 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分的数据长度在32位和64位的虚拟机（未开启压缩指针）中分别为 `32bit` 和 `64bit` 
2. 因为对象需要存储的运行数据很多，考虑到虚拟机的空间效率，Mark Word被设计成1个非固定的数据结构以便在极小的空间存储尽量多的信息（会根据对象状态复用存储空间）

+ 类型指针

&emsp;&emsp;即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据信息确定Java对象的大小，而数组对象不可以。

> 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。

## 实例数据

&emsp;&emsp;这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

&emsp;&emsp;这部分数据的存储顺序会受到虚拟机分配参数（FieldAllocationStyle）和字段在Java源码中定义顺序的影响。

&emsp;&emsp;HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointers)，从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提的条件下，父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。

## 对齐填充

&emsp;&emsp;这部分不是必然存在的，没有特别的含义，仅仅只是起着占位符的作用，用于保证对象大小是8个字节的整数倍。

> &emsp;&emsp;因HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。
>
> &emsp;&emsp;对象头部分正好是8字节的倍数（1倍或两倍）
>
> &emsp;&emsp;因此当对象实例数据部分没有对齐时，这部分就起作用了，用于对齐。

# 对象的访问定位

&emsp;&emsp;虚拟机建立对象是为了使用对象，那么如何使用对象呢？

&emsp;&emsp;Java程序需要通过栈上的reference数据来操作堆上的具体对象。

&emsp;&emsp;由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没定义该引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式取决于虚拟机实现。

&emsp;&emsp;目前主流的对象访问方式有两种：**句柄访问**和**直接指针**

+ 使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![img-25](https://note.youdao.com/yws/api/personal/file/CBF911D1EDE44E25A250535AB74DD907?method=download&shareKey=2aa1b8f7374e7a20f5a49f8af0d44894)

+ 使用直接指针访问的话，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址。

![img-26](https://note.youdao.com/yws/api/personal/file/4D31AA1687C042628742173D1CACE376?method=download&shareKey=eb1e3368a6658b7e7c2307e91907aa83)

&emsp;&emsp;这两种对象访问方式各有优势：

+ 使用句柄访问的好处是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集是移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，reference本身不需要修改。
+ 使用直接指针访问的好处是速度更快，它节省了一次指针定位的时间开销。

如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。

> HotSpot虚拟机是使用直接指针访问的方式进行对象访问，但如果从整个软件开发的范围来看，各种语言和框架使用句柄来访问的方式十分常见。