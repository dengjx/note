# 三次握手
**初始状态：** 客户端A和服务器B均处于CLOSED状态，然后服务器B创建socket，调用监听接口使得服务器处于LISTEN状态，等待客户端连接。(==即客户端与服务端不处于连接状态==)

三次握手（three times handshake；three-way handshake）所谓的“三次握手”即对每次发送的数据量是怎样跟踪进行协商使数据段的发送和接收同步，根据所接收到的数据量而确定的数据确认数及数据发送、接收完毕后何时撤消联系，并建立虚连接。

![三次握手](https://note.youdao.com/yws/api/personal/file/2CCD1ECDCBFF4F5FAE3A46685D7E87AB?method=download&shareKey=57f408efb447f49bb05e9d0eb893a06a)

过程：

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers），表示建立连接。即主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；即主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手，表示响应。即主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。

==简而言之：就是客户端(Client)向服务端(Server)发起连接请求，服务端收到连接请求后回应客户端是否确认连接，当客户端收到来自服务端的回应后向服务端发送确认连接请求，至此，三次握手流程结束，客户端与服务端连接开启。==

**为何不使用两次握手就开启连接？**  
三次握手最主要的目的就是**双方确认自己与对方的发送与接收是正常的**。也就是说，三次握手是为了防止已经失效的连接请求报文突然传输到服务端，因此产生的报错。

例如：  
客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，但是此时服务端仍然认为这是客户端的建立连接请求第一次握手，于是服务端回应了客户端，第二次握手。若是两次握手就建立连接了，那么就可能会出现客户端并没有任何数据要发送，而服务端还在等待客户端发送过来数据，这样会造成很大的资源浪费。

# 四次挥手
**初始状态：** 客户端和服务器之间已经建立了TCP连接，并且数据发送完成，打算断开连接，此时客户端和服务器是等价的，双方都可以发送断开请求，也就是说这个过程是由客户端或者服务端任一方发起关闭请求来触发的。

![四次挥手](https://note.youdao.com/yws/api/personal/file/2A244FA3167D4163A4D15ABF5399A2E7?method=download&shareKey=f0466806966ff82a84074c3c8597bc6a)

以客户端主动请求关闭为例：

+ 先由客户端向服务器端发送一个FIN，请求关闭数据传输。
+ 当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN+SEQ
+ 然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。
+ 当客户端收到服务器端的FIN是，回复一个ACK给服务器端。其中ack的值等于FIN+SEQ

**为什么要4次挥手？**  
确保数据能够完整传输。当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。